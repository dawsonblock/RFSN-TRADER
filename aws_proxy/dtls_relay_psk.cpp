#include <iostream>#include <vector>#include <string>#include <cstring>#include <sys/socket.h>#include <netinet/in.h>#include <arpa/inet.h>#include <unistd.h>#include <netdb.h>#include <fcntl.h>#include <sys/select.h>#include <openssl/ssl.h>#include <openssl/err.h>#include <openssl/rand.h>#define LISTEN_PORT 13370#define PSK_IDENTITY "client1"#define UPSTREAM_HOST "clob.polymarket.com"#define UPSTREAM_PORT "443"#define COOKIE_SECRET_LENGTH 16unsigned char cookie_secret[COOKIE_SECRET_LENGTH];int cookie_initialized = 0;/* --- PSK Callback --- */unsigned int psk_server_callback(SSL *ssl, const char *identity,                               unsigned char *psk, unsigned int max_psk_len) {    if (!identity) return 0;        std::cout << "[DEBUG] PSK Identity received: " << identity << std::endl;        if (strcmp(identity, PSK_IDENTITY) != 0) {        std::cerr << "[ERROR] Unknown PSK identity: " << identity << std::endl;        return 0;    }    // Key is 32 bytes of 'A' (0x41)    unsigned char key[32];    memset(key, 0x41, 32); // 0x41 is 'A'    if (max_psk_len < 32) return 0;    memcpy(psk, key, 32);    return 32;}/* --- Cookie Generation for DTLSv1_listen --- */int generate_cookie(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len) {    unsigned char *buffer, result[EVP_MAX_MD_SIZE];    unsigned int length = 0, resultlen;    struct sockaddr_in peer;    /* Initialize a random secret if not already done */    if (!cookie_initialized) {        if (!RAND_bytes(cookie_secret, COOKIE_SECRET_LENGTH)) {            std::cerr << "Error generating cookie secret" << std::endl;            return 0;        }        cookie_initialized = 1;    }    /* Read peer address from BIO */    (void) BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);    /* Calculate HMAC of peer address using secret */    HMAC(EVP_sha1(), (const void*)cookie_secret, COOKIE_SECRET_LENGTH,         (const unsigned char*)&peer, sizeof(peer), result, &resultlen);    memcpy(cookie, result, resultlen);    *cookie_len = resultlen;    return 1;}int verify_cookie(SSL *ssl, const unsigned char *cookie, unsigned int cookie_len) {    unsigned char *buffer, result[EVP_MAX_MD_SIZE];    unsigned int length = 0, resultlen;    struct sockaddr_in peer;    /* Initialize a random secret if not already done */    if (!cookie_initialized) return 0;    /* Read peer address from BIO */    (void) BIO_dgram_get_peer(SSL_get_rbio(ssl), &peer);    /* Calculate HMAC of peer address using secret */    HMAC(EVP_sha1(), (const void*)cookie_secret, COOKIE_SECRET_LENGTH,         (const unsigned char*)&peer, sizeof(peer), result, &resultlen);    if (cookie_len == resultlen && memcmp(result, cookie, resultlen) == 0)        return 1;    return 0;}/* --- Upstream TLS Connection --- */struct UpstreamConnection {    int sock = -1;    SSL_CTX *ctx = nullptr;    SSL *ssl = nullptr;    bool connect(const char* host, const char* port) {        // 1. Resolve        struct addrinfo hints = {}, *addrs;        hints.ai_family = AF_INET;        hints.ai_socktype = SOCK_STREAM;                if (getaddrinfo(host, port, &hints, &addrs) != 0) {            perror("getaddrinfo");            return false;        }        // 2. Socket        sock = socket(addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);        if (sock < 0) {            perror("socket upstream");            return false;        }        // 3. Connect TCP        if (::connect(sock, addrs->ai_addr, addrs->ai_addrlen) < 0) {            perror("connect upstream");            close(sock);            return false;        }        freeaddrinfo(addrs);        // 4. Init SSL        ctx = SSL_CTX_new(TLS_client_method());        if (!ctx) return false;                ssl = SSL_new(ctx);        SSL_set_fd(ssl, sock);                // SNI is important for many servers        SSL_set_tlsext_host_name(ssl, host);        // 5. Handshake        if (SSL_connect(ssl) <= 0) {            ERR_print_errors_fp(stderr);            return false;        }        std::cout << "[INFO] Connected to upstream " << host << ":" << port << std::endl;        return true;    }    void disconnect() {        if (ssl) SSL_free(ssl);        if (ctx) SSL_CTX_free(ctx);        if (sock >= 0) close(sock);        ssl = nullptr;        ctx = nullptr;        sock = -1;    }};/* --- Main Loop --- */int main() {    // Init OpenSSL    SSL_load_error_strings();    OpenSSL_add_ssl_algorithms();        // Create UDP Socket    int fd = socket(AF_INET, SOCK_DGRAM, 0);    if (fd < 0) {        perror("socket");        return 1;    }    // Reuse addr/port    int on = 1;    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (const void*)&on, sizeof(on));#ifdef SO_REUSEPORT    setsockopt(fd, SOL_SOCKET, SO_REUSEPORT, (const void*)&on, sizeof(on));#endif    struct sockaddr_in server_addr;    memset(&server_addr, 0, sizeof(server_addr));    server_addr.sin_family = AF_INET;    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);    server_addr.sin_port = htons(LISTEN_PORT);    if (bind(fd, (const struct sockaddr*)&server_addr, sizeof(server_addr))) {        perror("bind");        return 1;    }    // DTLS Context    SSL_CTX *ctx = SSL_CTX_new(DTLS_server_method());    SSL_CTX_set_read_ahead(ctx, 1);    SSL_CTX_set_cookie_generate_cb(ctx, generate_cookie);    SSL_CTX_set_cookie_verify_cb(ctx, verify_cookie);    SSL_CTX_set_psk_server_callback(ctx, psk_server_callback);    // Force PSK cipher suites if needed. 'ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH' usually includes PSK if configured.    // Explicitly enabling PSK:    SSL_CTX_set_cipher_list(ctx, "PSK-AES128-CBC-SHA:PSK-AES256-CBC-SHA");    std::cout << "DTLS Relay listening on UDP port " << LISTEN_PORT << std::endl;        while (true) {        BIO *bio = BIO_new_dgram(fd, BIO_NOCLOSE);        SSL *ssl = SSL_new(ctx);        SSL_set_bio(ssl, bio, bio);        SSL_set_options(ssl, SSL_OP_COOKIE_EXCHANGE);        struct sockaddr_in client_addr;        // Wait for incoming connection (DTLSv1_listen)        std::cout << "Waiting for incoming connection..." << std::endl;                while (DTLSv1_listen(ssl, (BIO_ADDR*)&client_addr) <= 0) {             // Handle errors or just loop (listen sends HelloVerifyRequest internally)             // We can check ERR stack if we want             ERR_clear_error();        }        std::cout << "[INFO] Accepted connection from client." << std::endl;        // Create new socket for the established connection        int connected_fd = socket(AF_INET, SOCK_DGRAM, 0);        if (connected_fd < 0) {            perror("socket connected");            SSL_free(ssl);             continue;        }        // Reuse addr on new socket        setsockopt(connected_fd, SOL_SOCKET, SO_REUSEADDR, (const void*)&on, sizeof(on));                // Connect to client to lock this socket to the peer        if (connect(connected_fd, (struct sockaddr*)&client_addr, sizeof(client_addr))) {            perror("connect");             SSL_free(ssl);              close(connected_fd);             continue;        }                // Set the SSL object to use the new file descriptor        BIO *sbio = BIO_new_dgram(connected_fd, BIO_CLOSE);        SSL_set_bio(ssl, sbio, sbio);                // Complete the handshake        if (SSL_accept(ssl) <= 0) {            ERR_print_errors_fp(stderr);            std::cout << "[ERROR] Handshake failed." << std::endl;            SSL_free(ssl);            continue;         }        std::cout << "[INFO] Handshake complete. Starting Relay..." << std::endl;        // Establish Upstream        UpstreamConnection upstream;        if (!upstream.connect(UPSTREAM_HOST, UPSTREAM_PORT)) {            std::cout << "[ERROR] Failed to connect upstream." << std::endl;            SSL_shutdown(ssl);            SSL_free(ssl);            continue;        }        // Relay Loop        char buf[4096];        bool running = true;                while (running) {            fd_set readfds;            FD_ZERO(&readfds);            FD_SET(connected_fd, &readfds);            FD_SET(upstream.sock, &readfds);                        int maxfd = (connected_fd > upstream.sock) ? connected_fd : upstream.sock;                        struct timeval timeout;            timeout.tv_sec = 60; // 1 min idle timeout            timeout.tv_usec = 0;            int activity = select(maxfd + 1, &readfds, NULL, NULL, &timeout);            if (activity < 0) {                perror("select");                break;            } else if (activity == 0) {                std::cout << "[INFO] Timeout, closing session." << std::endl;                break;            }            // Data from Client (DTLS) -> Upstream (TLS)            if (FD_ISSET(connected_fd, &readfds)) {                int len = SSL_read(ssl, buf, sizeof(buf));                if (len <= 0) {                    int err = SSL_get_error(ssl, len);                    if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {                        continue;                    }                    std::cout << "[INFO] Client disconnected (DTLS)" << std::endl;                    running = false;                } else {                    // Forward to Upstream                    if (SSL_write(upstream.ssl, buf, len) <= 0) {                        std::cout << "[ERROR] Upstream write failed" << std::endl;                        running = false;                    }                }            }            // Data from Upstream (TLS) -> Client (DTLS)            if (FD_ISSET(upstream.sock, &readfds)) {                int len = SSL_read(upstream.ssl, buf, sizeof(buf));                if (len <= 0) {                    int err = SSL_get_error(upstream.ssl, len);                    if (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE) {                        continue;                    }                    std::cout << "[INFO] Upstream disconnected" << std::endl;                    running = false;                } else {                     // Forward to Client                    if (SSL_write(ssl, buf, len) <= 0) {                        std::cout << "[ERROR] Client write failed" << std::endl;                        running = false;                    }                }            }        }                std::cout << "[INFO] Closing session." << std::endl;        upstream.disconnect();        SSL_shutdown(ssl);        SSL_free(ssl);    }     close(fd);    SSL_CTX_free(ctx);    EVP_cleanup();    return 0;}